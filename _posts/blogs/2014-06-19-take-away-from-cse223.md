---
layout: post
title: "CSE223中学到的东西"
category: blog
meta:
  location: UCSD
tags:
  - distributed_systems
  - distributed_computing
  - cse
  - golang
---

这一学期，选了CSE223，“Distributed Computing and Systems”，学到了非常多的东西。

分布式系统
-----------------

以前通过一些论文（Mapreduce, GFS ... ）和开源的系统（Hadoop）学习到了一些分布式系统的皮毛，觉得分布式系统最主要的是性能，通过很多台机器，整个系统的性能（计算能力，存储能力）都能够得到提升，并且能够容忍一些错误的发生（机器或硬盘故障）。但是在课上，了解到真正的分布式系统要复杂得多。

性能的提升和可靠性是分布式系统的最基本的目标。

- 可靠性（Reliability），主要体现在
  + 容错（failure tolerance）
  + Availability
  + 正确的操作，安全性（correct operation, safety）
  + 一致性（consistency），这是十分重要的。
- 性能（Performance），主要是
  + 延迟（Latency, Response time）：响应的时间
  + 吞吐量（Throughput）
  + 扩展性（比如通过扩大分布的规模来获取更好的性能）
- Federation, Autonomy（原子性）
- 透明（Transparency）

这一门课让我印象最深的就是一致性问题的处理。分布式系统通过增加系统的规模，使用适当的冗余备份（Replica），来提供容错，Availability，容错和性能。但是有了多个机器和冗余备份，他们和客户端之间少不了有消息传递。如何保证各个机器对消息内容，消息顺序的一致，如何保证备份内容的一致，如何处理网络和机器的failuire，如何处理收到攻击的机器，这些都是分布式系统要考虑的问题。

### 为什么一致性是一个问题

当有了多个机器的时候，找到一个他们一致认同时间是一件几乎不可能做到的事情。如果按照每个机器的时间来对事件，消息进行排序，每个机器上顺序很有可能是不一致的。消息不一致，或者说有些机器被没有接到消息，那么储存在这些机器的数据们也是很有可能不一致。那么对于外界的客户端所访问到的数据就很有可能不一致。这些不一致就会导致一些错误，系统就会不安全。

在最初的GFS和Hadoop中，使用单一的主节点可以很容易地就解决这样的问题，但是这个单一的节点很容易就会成为性能的瓶颈。

### 消息，事件的顺序（Ordering）

- FIFO，比如TCP，就是一种先入先出的协议，但是它针对group的。我们可以使用一个中心的协调者（cental coordinator）来解决group的问题，但是这不是一种可靠地方法。如果可靠地实现FIFO，
  开销是十分大的
- Causual Ordering，各个消息之间满足一些偏序的关系，但是组内成员对于没有偏序关系的消息有各自的排序。可以通过CBCast协议来实现。
- Total Ordering，组内的成员对于消息有着一致排序，但是消息不一定满足偏序关系。通过ABCast。

### 一致性模型

课上介绍了一些系统和它们一致性的模型。在系统中，不同机器上可能存在着同一个数据的缓存，这些机器（进程）都会对缓存进行着一些读写操作。这里就是讨论的是读写操作和缓存的一致性。

- strict consistency, 所有操作都是原子的，线性的。也就是说，读写操作是按照事情发生的顺序执行的。
- sequential consistency，在系统中保证在每个机器（不同进程）间有着一个Total Ordering，这个顺序不一定发生的顺序。
- release consistency，在对一段缓存进行读写的时候，通过release和aquire在获取一个“锁”，这样保证缓存的一致性。如果没有锁操作，缓存的更改不会传递（propagate）到其他机器的缓存上。对于更改传递的时机，有分为eager和lazy两种。

### 操作的原子性

对于如何保证一个操作，事务的原子性，在一台机器上的时候，可以通过锁和Log的方式在保证。但是在分布式系统中，这样子是没有办法实现的。课堂上有一个ATM的例子，如何取款操作的原子性。如果ATM机吐出钱了，远程的服务器就必须把钱从账户中扣去。如果这之间发生了任何问题（机器，网络），两边的操作都是同时成功或同时失败。在分布式系统中，通过两段提交（Two Phase Commit）可以最终解决这样的一个问题。（具体的内容 TODO）

### 另一种一致性（consensus）

在分布式系统中，进程之间如何达成“共识”。比如说，A机器说“我要把这个值改成A”，B说，我要改成“B“，那到底改成多少，这就是一个问题。Paxos算法通过一种消息传递的方式，很有效地解决了这个问题。在Google的Spanner和Chubby中，Paxos都得到了广泛地应用。（具体的内容 TODO）

### Byzantine Failure

在分布式系统中，有的时候要处理机器受到攻击的情况。这个时候，系统里的机器不一定是可以信任的。但是如何在这些不可信任的机器中得到正确地结果呢。（具体内容 TODO）

但是这样的失效在一个系统内部很多情况下是可以避免的。所以很多商业的分布式系统都不会去考虑拜占庭失效的问题，因为为了方式几乎不可能的问题而在很大程度上妥协系统的性能是不可取的。

### 神奇的Spanner

课程的一开始，老师提到在分布式系统中实现一个“True Time”是不可能的。但是Spanner就“做到”了。不过，它并不是提供了真正的“True Time”。它是使用很精确的时钟（原子钟）来提供误差很小时钟同步。然后在真正写事务的时候，通过“等待”把这样的误差消除。得益于这种近似的“True Time”，Spanner能够实现无锁的读事务和提供外部一致性（External Consistency，无论系统内部怎样，系统外部都认为系统内部是一致的）。

Golang
------

这一门课的实验是需要学习一门新的语言Golang。虽然学习的一开始有些抱怨。但是学深入进去之后，觉得着确实是不错的工具，让我们可以不用考虑一些细小的问题，进而专注于实际需要解决的问题。学习之后，最后的项目我也果断地选择Golang来实现。

Golang是一个强大的工具，可以说它是为分布式系统而生的。但是没有哪个语言是完美的。Golang的设计也包含了很多的“Trade Off”，会使一些开发者不习惯。

Golang的目标是“快速编译”，“对依赖进行控制”，“垃圾回收”，“为多核设计”以及一些软件工程上的考虑。

为了实现这些目标，Golang做出了许多权衡，舍弃了很多东西。为了快速地编译，Golang的没有像C++和Java一样提供层级的类型系统。Golang的类型系统式扁平的，隐式的借口什么也使Golang更加灵活。对于垃圾回收，它可能会降低系统的效率（C和C++都是开发者自己进行垃圾回收），但是在并发程序设计中，垃圾回收回增加设计和开发的时间，增加犯错误的可能性。为了软件工程的一些考虑，golang也做了很多限制。如果不遵守相应地编码规范，根本编译不过。比如没有用到的变量声明，在其他语言中最多可能是warning，但在golang中根本无法编译。再比如golang在对于错误处理方式的取舍以及舍弃assert的问题。语言的设计者的认为使用异常让开发者很多时候生产出复杂的代码以及关心一些没有必要地异常。而C语言的这种扁平的方式是更加优雅。确实，很多系统级的程序里很少用到异常的错误处理方式。而对于assert，设计者认为它们确实十分方便，但是再实践中通常会让开发者回避去思考一些十分重要的错误处理。这不是语言设计的优劣问题。Golang是为大型系统开发设计的，设计者结合多年的软件工程实践经验认为，如果这些细节得不到关注，系统的质量就很难得到保证。

Golang不能取代现在的任何一种语言，也不比任何一种语言更加优越。我喜欢它的原因是它有和Python一样的设计哲学，它的背后有设计者对Google多年软件工程实践经验的总结，在取舍中有着很深的思考。

Log
---------

在数据库系统中学过Undo Log和Redo Log，在操作系统中接触到Log的操作系统。然而通过了实验，才真正初步理解了Log。在Lab3中，通过使用Log，很容易就能够保证了三个备份的一致性。以及防止数据迁移和数据读写的冲突。

CSE223可以说是我上大学以来学到东西最多，收获也最大的一门课。虽然10周上下来时间十分紧张，直到最后2分钟才把最后的报告写完交掉o(╯□╰)o
