---
layout: post
title: 软件架构复习笔记(2) -- 设计的审美标准，设计的层次性
category: note
home: no
published: true
meta:
  location: NJU
tags: [architecture, review, note]
---

h2. 软件设计的审美标准

h3. 审美标准是什么

* 简洁性：模块化
* 一致性（概念完整性）：体系结构的风格，模块化
* 坚固性（高质量）：最重要的是体现在体系结构上，设计模式所要解决的问题，模块化
  ** 易复用
  ** 易修改
  ** 易读
  ** 易理解
  ** 易维护
  ** 可靠性 (availability 可以正常工作, reliability 故障和故障修复)
  ** 性能，质量相关
  ** 易开发

h3. 列举已知的设计方法与技术（至少5中），他们促进了那些审美标准的达成

模块化：促进了结构一致性，坚固性（易维护，易复用等），促进了简洁性
信息隐藏：促进了一致性，坚固性（易维护，易复用），破坏了简洁性 ？？模块化 + 可修改性 = 信息隐藏，模块化促进简洁性，信息隐藏破坏简洁性？也有可能是对于使用模块的人促进了简洁性，但是对于尝试理解的人破坏了简洁性？
设计模式：促进了坚固性（易复用，易维护等等），一致性？
体系结构风格：促进了一致性，坚固性
职责分配（GRASP）：促进了坚固性，一致性
协作设计：促进了坚固性，一致性？


h2. 设计的层次性

问题：高层设计、中层设计和低层设计各自的出发点、主要关注因素（即那些审美要素）、主要方法与技术和最终制品


h3. 低层设计（代码设计）

出发点：
* 程序语言所提供的数据结构等东西太少了
* 为了解决类型的适配的问题
* 底层设计将基本的语言单位（类型与语句），组织起来，建立高质量的数据结构 + 算法

关注点：
* 简洁性
* 部分坚固性，包括坚固性的，易读，易维护，数据结构易用，算法可靠、易读
* 屏蔽程序中复杂数据结构与算法的实现细节

主要技术：

* Defensive Programming
* Assertive Programming (Design-by-Contract)
* Test-Driven Programming
* Error handling, exception handling
* Configuring Programming
* Table-driven Protramming
* State-mathine based Programming

前面四个是关于可靠性的，后面三个是关于数据结构带来易读性

内部结构是算法和数据类型，外在表现是抽象数据类型

最终制品：源程序，中层，底层共享了详细设计文档


h3. 中层设计（模块与类结构设计）

出发点：
* 想要使复杂的东西变简单
* 把复杂的东西分解成尽可能独立的片段

关注点：
* 简洁性（易开发，易修改，易复用？）
* 可观察性（易开发，易调试，易复用）
* 一致性（一些要求，如高内聚，低耦合等）
* 坚固性（易开发，易修改，易复用，易开发等）

问题困难：程序片段不可能完全独立
方法：实现尽可能的独立（低耦合，高内聚）
主要的方法：
* 高内聚
* 低耦合
* 模块化
* 信息隐藏

最终制品：类和模块

h3. 高层设计

出发点：
* 主要为了解决整体功能组织的问题
* 组织的时候设计和功能
* 总体结构和质量属性

关注点:
** 简洁性
** 一致性
** 坚固性

方法：
* 场景驱动
* 体系结构风格

为什么要高层设计:
* 名称匹配, 导入导出（问题）
* Inside 接口（独立，区别对待）
* 详细设计的不足
  ** 载体适配（无法描述可靠性，性能）
  ** 无法实现交互信息本地化（信息隐藏的局限性），Inside
无法有效抽象部件的整体特性
  ** 接口定义缺乏结构性（交互的规则，如果A调用是B必须调用）
  ** 不能有效适应大型软件的特殊开发方法

最终制品：体系结构的设计
